<?php
namespace Yiisoft\Mailer;

use Psr\EventDispatcher\EventDispatcherInterface;
use Psr\Log\LoggerInterface;
use Yiisoft\Mailer\Event\{AfterSend, BeforeSend};

/**
 * BaseMailer serves as a base class that implements the basic functions required by [[MailerInterface]].
 *
 * Concrete child classes may focus on implementing the [[sendMessage()]] method.
 */
abstract class BaseMailer implements MailerInterface
{
    /**
     * @var bool whether to save email messages as files under [[fileTransportPath]] instead of sending them
     * to the actual recipients. This is usually used during development for debugging purpose.
     * @see fileTransportPath
     */
    private $useFileTransport = false;

    /**
     * Returns a bool value that indicating whether use file transport.
     * @return bool
     */
    public function getUseFileTransport(): bool
    {
        return $this->useFileTransport;
    }

    /**
     * Sets a bool value that indicating whether use file transport.
     * @param bool $value
     */
    public function setUseFileTransport(bool $value)
    {
        $this->useFileTransport = $value;
    }

    /**
     * @var string the directory where the email messages are saved when [[useFileTransport]] is true.
     */
    private $fileTransportPath = '/tmp/mail';

    /**
     * Returns file transport path.
     * @return string
     */
    public function getFileTransportPath(): string
    {
        return $this->fileTransportPath;
    }

    /**
     * Sets file transport path.
     * @param string $path
     */
    public function setFileTransportPath(string $path)
    {
        $this->fileTransportPath = $path;
    }

    /**
     * @var callable a PHP callback that will be called by [[send()]] when [[useFileTransport]] is true.
     * The callback should return a file name which will be used to save the email message.
     * If not set, the file name will be generated based on the current timestamp.
     *
     * The signature of the callback is:
     *
     * ```php
     * function ($mailer, $message)
     * ```
     */
    private $fileTransportCallback;

    /**
     * Sets file transport callback.
     * @param callable $callback
     */
    public function setFileTransportCallback(Callable $callback)
    {
        $this->fileTransportCallback = $callback;
    }

    /**
     * @var MessageFactoryInterface $messageFactory
     */
    private $messageFactory;

    /**
     * @var Composer $composer Message composer instance.
     */
    private $composer;

    /**
     * @var EventDispatcherInterface $eventDispatcher.
     */
    private $eventDispatcher;

    /**
     * @var LoggerInterface $logger.
     */
    private $logger;

    /**
     * @param MessageFactoryInterface $messageFactory
     * @param Composer $composer
     * @param EventDispatcherInterface $eventDispatcher
     * @param LoggerInterface $logger
     */
    public function __construct(MessageFactoryInterface $messageFactory, Composer $composer, EventDispatcherInterface $eventDispatcher, LoggerInterface $logger)
    {
        $this->messageFactory = $messageFactory;
        $this->composer = $composer;
        $this->eventDispatcher = $eventDispatcher;
        $this->logger = $logger;
    }

    /**
     * @return Composer message composer instance.
     */
    public function getComposer(): Composer
    {
        return $this->composer;
    }

    /**
     * Creates a new message instance and optionally composes its body content via view rendering.
     *
     * @param string|array|null $view the view to be used for rendering the message body. This can be:
     *
     * - a string, which represents the view name for rendering the HTML body of the email.
     *   In this case, the text body will be generated by applying `strip_tags()` to the HTML body.
     * - an array with 'html' and/or 'text' elements. The 'html' element refers to the view name
     *   for rendering the HTML body, while 'text' element is for rendering the text body. For example,
     *   `['html' => 'contact-html', 'text' => 'contact-text']`.
     * - null, meaning the message instance will be returned without body content.
     *
     * The view to be rendered can be specified in one of the following formats:
     *
     * - a relative view name (e.g. "contact") located under [[viewPath]].
     *
     * @param array $params the parameters (name-value pairs) that will be extracted and made available in the view file.
     * @return MessageInterface message instance.
     */
    public function compose($view = null, array $params = []): MessageInterface
    {
        $message = $this->createMessage();
        if ($view === null) {
            return $message;
        }

        $this->composer->compose($message, $view, $params);

        return $message;
    }

    /**
     * Creates a new message instance.
     * @return MessageInterface message instance.
     */
    protected function createMessage(): MessageInterface
    {
        return $this->messageFactory->create($this);
    }

    /**
     * Sends the given email message.
     * This method will log a message about the email being sent.
     * If [[useFileTransport]] is true, it will save the email as a file under [[fileTransportPath]].
     * Otherwise, it will call [[sendMessage()]] to send the email to its recipient(s).
     * Child classes should implement [[sendMessage()]] with the actual email sending logic.
     * @param MessageInterface $message email message instance to be sent
     * @return bool whether the message has been sent successfully
     */
    public function send(MessageInterface $message): bool
    {
        if (!$this->beforeSend($message)) {
            return false;
        }

        $address = $message->getTo();
        if (is_array($address)) {
            $address = implode(', ', array_keys($address));
        }
        $this->logger->info('Sending email "' . $message->getSubject() . '" to "' . $address . '"');

        if ($this->useFileTransport) {
            $isSuccessful = $this->saveMessage($message);
        } else {
            $isSuccessful = $this->sendMessage($message);
        }
        $this->afterSend($message, $isSuccessful);

        return $isSuccessful;
    }

    /**
     * Sends multiple messages at once.
     *
     * The default implementation simply calls [[send()]] multiple times.
     * Child classes may override this method to implement more efficient way of
     * sending multiple messages.
     *
     * @param array $messages list of email messages, which should be sent.
     * @return int number of messages that are successfully sent.
     */
    public function sendMultiple(array $messages): int
    {
        $successCount = 0;
        foreach ($messages as $message) {
            if ($this->send($message)) {
                $successCount++;
            }
        }

        return $successCount;
    }

    /**
     * Sends the specified message.
     * This method should be implemented by child classes with the actual email sending logic.
     * @param MessageInterface $message the message to be sent
     * @return bool whether the message is sent successfully
     */
    abstract protected function sendMessage(MessageInterface $message): bool;

    /**
     * Saves the message as a file under [[fileTransportPath]].
     * @param MessageInterface $message
     * @return bool whether the message is saved successfully
     */
    protected function saveMessage(MessageInterface $message): bool
    {
        $path = $this->fileTransportPath;
        if (!is_dir($path)) {
            mkdir($path, 0777, true);
        }
        if ($this->fileTransportCallback !== null) {
            $filename = call_user_func($this->fileTransportCallback, $this, $message);
        } else {
            $filename = $this->generateMessageFileName();
        }
        file_put_contents($path . DIRECTORY_SEPARATOR . $filename, $message->toString());

        return true;
    }

    /**
     * @return string the file name for saving the message when [[useFileTransport]] is true.
     */
    protected function generateMessageFileName(): string
    {
        $time = microtime(true);

        return date('Ymd-His-', $time) . sprintf('%04d', (int) (($time - (int) $time) * 10000)) . '-' . sprintf('%04d', mt_rand(0, 10000)) . '.eml';
    }

    /**
     * This method is invoked right before mail send.
     * You may override this method to do last-minute preparation for the message.
     * If you override this method, please make sure you call the parent implementation first.
     * @param MessageInterface $message
     * @return bool whether to continue sending an email.
     */
    protected function beforeSend(MessageInterface $message)
    {
        /** @var BeforeSend $event */
        $event = $this->eventDispatcher->dispatch(new BeforeSend($message));
        return !$event->isPropagationStopped();
    }

    /**
     * This method is invoked right after mail was send.
     * You may override this method to do some postprocessing or logging based on mail send status.
     * If you override this method, please make sure you call the parent implementation first.
     * @param MessageInterface $message
     * @param bool $isSuccessful
     */
    protected function afterSend(MessageInterface $message, $isSuccessful)
    {
        $this->eventDispatcher->dispatch(new AfterSend($message, $isSuccessful));
    }
}
